<!DOCTYPE html>
<html>
  <head>
    <!-- Google tag (gtag.js) -->
    <script
      async
      src="https://www.googletagmanager.com/gtag/js?id=G-Y5SL7C9VE8"
    ></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());

      gtag("config", "G-Y5SL7C9VE8");
    </script>
    <title>LLMChess</title>
    <link
      rel="stylesheet"
      href="{{url_for('static', filename='css/chessboard-1.0.0.min.css')}}"
    />
    <script src="https://code.jquery.com/jquery-1.12.4.min.js"></script>
    <script src="{{url_for('static', filename='js/chessboard-1.0.0.min.js')}}"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.2/chess.min.js"></script>
  </head>
  <body>
    <div id="input-container">
      <input type="text" id="api-key-input" placeholder="OpenAI Key" />
      <select id="model-selector">
        <option value="gpt-3.5-turbo">gpt-3.5-turbo</option>
        <option value="gpt-3.5-turbo-0301">gpt-3.5-turbo-0301</option>
        <option value="gpt-4">gpt-4</option>
        <option value="gpt-4-0314">gpt-4-0314</option>
        <option value="gpt-4-32k">gpt-4-32k</option>
        <option value="gpt-4-32k-0314">gpt-4-32k-0314</option>
      </select>
      <button id="start-button">Start</button>
    </div>
    <div class="game-container" style="display: flex">
      <div id="spinner" style="display: none">
        <img alt="Loading..." />
      </div>

      <div id="board1" style="width: 400px; margin-right: 50px"></div>
      <div
        id="log"
        style="
          width: 200px;
          height: 400px;
          border: 1px solid black;
          overflow-y: auto;
          white-space: pre-wrap;
          word-wrap: break-word;
        "
      ></div>
      <div id="waiting-message" style="display: none">
        Waiting for the LLM to respond...
      </div>
    </div>
    <div id="instructions">
      <p>Read:</p>
      <ol>
        <li>
          In order for it to operate, just select the model to which you have
          access using your API key.
        </li>
        <li>You use white to play.</li>
        <li>The game will begin if the "Start" button changes to "End."</li>
        <li>
          Reload your browser or use the "End" button to restart the game.
        </li>
        <li>In the right-hand pane with a black border, logs appear.</li>
        <li>
          If the game does not respond at the beginning, restart the game.
        </li>
        <li>Tested in Google Chrome browser.</li>
        <li>
          In my experience, the only way to play a respectable game is with
          GPT-4. The system still needs improvement and is looking for
          contributors. Discover how it functions and how to participate
          <a href="https://maxhager.xyz/LLMChess">here</a>.
        </li>
        <li>
          Created by <a href="https://twitter.com/MaxHager66">Max Hager</a>
        </li>
      </ol>
    </div>
    <script>
      function displayLogMessage(message) {
        var log = document.getElementById("log");
        log.innerHTML += message + "\n";
        log.scrollTop = log.scrollHeight; // Automatically scroll to the bottom
      }

      function createNewSession() {
        return new Promise((resolve, reject) => {
          $.ajax({
            url: "/new-session",
            method: "GET",
            success: function (response) {
              console.log(response.session_id);
              if (response.session_id) {
                resolve(response.session_id);
              } else {
                reject("Error creating new session");
              }
            },
            error: function (error) {
              reject(error);
            },
          });
        });
      }

      var gameStarted = false;
      var selectedModel = document.getElementById("model-selector").value;
      document
        .getElementById("model-selector")
        .addEventListener("change", function () {
          selectedModel = this.value;
        });

      document
        .getElementById("start-button")
        .addEventListener("click", async function () {
          // Check if the game is already started
          if (gameStarted) {
            console.log("shouldt delete");
            deleteSession();
            //location.reload();
            return;
          }

          // Get the API key from the input field
          var apiKey = document.getElementById("api-key-input").value;

          // Check if the input field is empty
          if (apiKey.trim() === "") {
            alert("Please enter a valid API key to start the game.");
          } else {
            try {
              const response = await fetch("/check-api-key", {
                method: "POST",
                headers: {
                  "Content-Type": "application/x-www-form-urlencoded",
                },
                body: `api_key=${apiKey}`,
              });
              const data = await response.json();
              if (data.status === "success") {
                const setApiKeyResponse = await fetch("/set-api-key", {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/x-www-form-urlencoded",
                  },
                  body: `api_key=${apiKey}&model=${selectedModel}`,
                });
                const setApiKeyData = await setApiKeyResponse.json();
                if (setApiKeyData.status === "success") {
                  try {
                    const sessionId = await createNewSession();
                    console.log("Session ID:", sessionId);
                    if (sessionId) {
                      gameStarted = true;
                      var startButton = document.getElementById("start-button");
                      startButton.textContent = "End";
                      getLogs();
                    } else {
                      alert(
                        "Failed to create a new session. Please try again."
                      );
                    }
                  } catch (error) {
                    console.error("Error creating new session:", error);
                  }
                } else {
                  alert("Failed to set the API key. Please try again.");
                }
              } else {
                alert(
                  "The provided API key is not valid. Please enter a valid API key."
                );
              }
            } catch (error) {
              console.error("Error during the AJAX request:", error);
            }
          }
        });

      function updatePositionWithLoad(chess, source, target, piece) {
        // Remove the piece from the source square
        chess.remove(source);

        // Put the piece on the target square
        chess.put(piece, target);

        // Generate the FEN string for the updated position
        var updatedFen = chess.fen();

        // Load the position from the FEN string to update en passant square and castling flags
        chess.load(updatedFen);
      }

      var img_url =
        "{{ url_for('static', filename='img/chesspieces/wikipedia/') }}";
      var board1,
        game = new Chess();

      var config = {
        draggable: true,
        position: "start",
        onDragStart: onDragStart,
        onDrop: onDrop,
        onMouseoutSquare: onMouseoutSquare,
        onMouseoverSquare: onMouseoverSquare,
        onSnapEnd: onSnapEnd,
        pieceTheme: img_url + "{piece}.png",
      };

      board1 = ChessBoard("board1", config);

      function onDragStart(source, piece, position, orientation) {
        // Do not pick up pieces if the game hasn't started
        if (!gameStarted) {
          return false;
        }

        // Do not pick up pieces if the game is over
        if (game.in_checkmate() === true || game.in_draw() === true) {
          return false;
        }

        // Only pick up pieces for the side to move
        if (
          (game.turn() === "w" && piece.search(/^b/) !== -1) ||
          (game.turn() === "b" && piece.search(/^w/) !== -1)
        ) {
          return false;
        }
      }

      function onDrop(source, target) {
        // See if the move is legal
        var move = game.move({
          from: source,
          to: target,
          promotion: "q", // NOTE: always promote to a queen for simplicity
        });

        // Illegal move
        if (move === null) {
          return "snapback";
        }

        // Update the board position after a legal move
        updateStatus();

        // Check if the game is over
        if (
          game.in_checkmate() ||
          game.in_draw() ||
          game.in_stalemate() ||
          game.in_threefold_repetition() ||
          game.insufficient_material() ||
          game.half_moves >= 100
        ) {
          // Game is over, do not send the move to the server
          return;
        }

        sendMoveToServer(move);
      }

      function onMouseoverSquare(square, piece) {
        // Add any interaction when the mouse is over a square
      }

      function onMouseoutSquare(square, piece) {
        // Add any interaction when the mouse leaves a square
      }

      function onSnapEnd() {
        // Update the board position after the piece snap
        board1.position(game.fen());
      }

      function updateStatus() {
        var status = "";

        var moveColor = game.turn() === "w" ? "White" : "Black";

        // check for checkmate
        if (game.in_checkmate()) {
          status = "Game over, " + moveColor + " is in checkmate.";
        }

        // check for draw
        else if (game.in_draw()) {
          status = "Game over, drawn position";
        }

        // check for stalemate
        else if (game.in_stalemate()) {
          status = "Game over, stalemate";
        }

        // check for threefold repetition
        else if (game.in_threefold_repetition()) {
          status = "Game over, threefold repetition";
        }

        // check for insufficient material
        else if (game.insufficient_material()) {
          status = "Game over, insufficient material";
        }

        // check for 50-move rule
        else if (game.half_moves >= 100) {
          status = "Game over, 50-move rule";
        }

        if (status !== "") {
          displayLogMessage(status);
        }
      }

      //i am trying to send a move to my server. i call the sendMoveToServer method inside the sendMoveToServer itself if a move is not available, i.e. a invalid session appears. how can i

      function sendMoveToServer(move) {
        const sessionId = sessionStorage.getItem("session_id");
        console.log("Sending session_id from frontend:", sessionId);
        // Show the waiting message
        document.getElementById("waiting-message").style.display = "block";
        $.ajax({
          url: "/move",
          method: "POST",
          data: {
            from: move.from,
            to: move.to,
            promotion: move.promotion,
          },
          success: function (response) {
            // Hide the waiting message
            document.getElementById("waiting-message").style.display = "none";
            console.log(response);
            // Check if response.bestMove exists
            if (response.move) {
              var move = response.move;
            } else {
              console.log("hello");
            }
            /*else {
              //create new session and call move again
              createNewSession();
              sendMoveToServer(move);
              var move = null;
            }*/
            if (move) {
              game.move(move, { sloppy: true });
              board1.position(game.fen());
              updateStatus();
            }
          },
        });
      }

      // Function to delete the session
      async function deleteSession() {
        try {
          const response = await fetch("/delete-session");
          const data = await response.json();
          if (data.status === "success") {
          } else {
          }
        } catch (error) {}
      }

      async function getLogs() {
        try {
          const response = await fetch("/get_logs");
          const data = await response.json();
          if (data.log) {
            // Create a new div for the log entry
            const logEntry = document.createElement("div");

            // Check if the log is an error or success, and set the color accordingly
            if (data.log.includes("illegal")) {
              logEntry.style.color = "red";
            } else {
              logEntry.style.color = "green";
            }
            // Set the log entry text
            logEntry.innerHTML = data.log;
            // Append the log entry to the log container
            document.getElementById("log").appendChild(logEntry);
          }
        } catch (error) {
          console.error("Error fetching logs:", error);
        } finally {
          setTimeout(getLogs, 500);
        }
      }
      // Add this function in your script tag
      function startRealTimeLogs() {
        getLogs();
        setTimeout(startRealTimeLogs, 1000);
      }

      //window.addEventListener("load", deleteSession);
    </script>
  </body>
</html>
