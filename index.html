<!DOCTYPE html>
<html>
  <head>
    <title>Chess</title>
    <link
      rel="stylesheet"
      href="{{url_for('static', filename='css/chessboard-1.0.0.min.css')}}"
    />
    <script src="https://code.jquery.com/jquery-1.12.4.min.js"></script>
    <script src="{{url_for('static', filename='js/chessboard-1.0.0.min.js')}}"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.2/chess.min.js"></script>
  </head>
  <body>
    <div id="input-container">
      <input type="text" id="api-key-input" placeholder="OpenAI Key" />
      <select id="model-selector">
        <option value="gpt-3.5-turbo">gpt-3.5-turbo</option>
        <option value="gpt-3.5-turbo-0301">gpt-3.5-turbo-0301</option>
        <option value="gpt-4">gpt-4</option>
        <option value="gpt-4-0314">gpt-4-0314</option>
        <option value="gpt-4-32k">gpt-4-32k</option>
        <option value="gpt-4-32k-0314">gpt-4-32k-0314</option>
      </select>
      <button id="start-button">Start</button>
      <div>
        (make sure you choose a model which is working with your api key
        otherwise its not working)
      </div>
    </div>
    <div class="game-container" style="display: flex">
      <div id="spinner" style="display: none">
        <img alt="Loading..." />
      </div>

      <div id="board1" style="width: 400px; margin-right: 50px"></div>
      <div
        id="log"
        style="
          width: 200px;
          height: 400px;
          border: 1px solid black;
          overflow-y: auto;
          white-space: pre-wrap;
          word-wrap: break-word;
        "
      ></div>

      <div id="waiting-message" style="display: none">
        Waiting for the LLM to respond...
      </div>
    </div>
    <div></div>
    <script>
      function displayLogMessage(message) {
        var log = document.getElementById("log");
        log.innerHTML += message + "\n";
        log.scrollTop = log.scrollHeight; // Automatically scroll to the bottom
      }

      function createNewSession() {
        return new Promise((resolve, reject) => {
          $.ajax({
            url: "/new-session",
            method: "GET",
            success: function (response) {
              if (response.session_id) {
                resolve(response.session_id);
              } else {
                reject("Error creating new session");
              }
            },
            error: function (error) {
              reject(error);
            },
          });
        }).then(() => {
          // Call getLogs after the session has been created
          getLogs();
        });
      }

      var gameStarted = false;
      var selectedModel = document.getElementById("model-selector").value;
      document
        .getElementById("model-selector")
        .addEventListener("change", function () {
          selectedModel = this.value;
        });

      document
        .getElementById("start-button")
        .addEventListener("click", async function () {
          // Check if the game is already started
          if (gameStarted) {
            location.reload();
            return;
          }

          // Get the API key from the input field
          var apiKey = document.getElementById("api-key-input").value;

          // Check if the input field is empty
          if (apiKey.trim() === "") {
            alert("Please enter a valid API key to start the game.");
          } else {
            // Check if the API key is valid
            try {
              const response = await fetch("/check-api-key", {
                method: "POST",
                headers: {
                  "Content-Type": "application/x-www-form-urlencoded",
                },
                body: `api_key=${apiKey}`,
              });
              const data = await response.json();
              if (data.status === "success") {
                try {
                  const setApiKeyResponse = await fetch("/set-api-key", {
                    method: "POST",
                    headers: {
                      "Content-Type": "application/x-www-form-urlencoded",
                    },
                    body: `api_key=${apiKey}&model=${selectedModel}`,
                  });
                  const setApiKeyData = await setApiKeyResponse.json();
                  if (setApiKeyData.status === "success") {
                    gameStarted = true;
                    var startButton = document.getElementById("start-button");
                    startButton.textContent = "End";
                    try {
                      const sessionId = await createNewSession();
                    } catch (error) {
                      console.error("Error creating new session:", error);
                    }
                  } else {
                  }
                } catch (error) {
                  console.error("Error during the AJAX request:", error);
                }
              } else {
                alert(
                  "The provided API key is not valid. Please enter a valid API key."
                );
              }
            } catch (error) {
              console.error("Error during the AJAX request:", error);
            }
          }
        });

      function updatePositionWithLoad(chess, source, target, piece) {
        // Remove the piece from the source square
        chess.remove(source);

        // Put the piece on the target square
        chess.put(piece, target);

        // Generate the FEN string for the updated position
        var updatedFen = chess.fen();

        // Load the position from the FEN string to update en passant square and castling flags
        chess.load(updatedFen);
      }

      var img_url =
        "{{ url_for('static', filename='img/chesspieces/wikipedia/') }}";
      var board1,
        game = new Chess();

      var config = {
        draggable: true,
        position: "start",
        onDragStart: onDragStart,
        onDrop: onDrop,
        onMouseoutSquare: onMouseoutSquare,
        onMouseoverSquare: onMouseoverSquare,
        onSnapEnd: onSnapEnd,
        pieceTheme: img_url + "{piece}.png",
      };

      board1 = ChessBoard("board1", config);

      function onDragStart(source, piece, position, orientation) {
        // Do not pick up pieces if the game hasn't started
        if (!gameStarted) {
          return false;
        }

        // Do not pick up pieces if the game is over
        if (game.in_checkmate() === true || game.in_draw() === true) {
          return false;
        }

        // Only pick up pieces for the side to move
        if (
          (game.turn() === "w" && piece.search(/^b/) !== -1) ||
          (game.turn() === "b" && piece.search(/^w/) !== -1)
        ) {
          return false;
        }
      }

      function onDrop(source, target) {
        // See if the move is legal
        var move = game.move({
          from: source,
          to: target,
          promotion: "q", // NOTE: always promote to a queen for simplicity
        });

        // Illegal move
        if (move === null) {
          return "snapback";
        }

        // Update the board position after a legal move
        updateStatus();

        // Check if the game is over
        if (
          game.in_checkmate() ||
          game.in_draw() ||
          game.in_stalemate() ||
          game.in_threefold_repetition() ||
          game.insufficient_material() ||
          game.half_moves >= 100
        ) {
          // Game is over, do not send the move to the server
          return;
        }

        // Send the move to the server
        sendMoveToServer(move);
      }

      function onMouseoverSquare(square, piece) {
        // Add any interaction when the mouse is over a square
      }

      function onMouseoutSquare(square, piece) {
        // Add any interaction when the mouse leaves a square
      }

      function onSnapEnd() {
        // Update the board position after the piece snap
        board1.position(game.fen());
      }

      function updateStatus() {
        var status = "";

        var moveColor = game.turn() === "w" ? "White" : "Black";

        // check for checkmate
        if (game.in_checkmate()) {
          status = "Game over, " + moveColor + " is in checkmate.";
        }

        // check for draw
        else if (game.in_draw()) {
          status = "Game over, drawn position";
        }

        // check for stalemate
        else if (game.in_stalemate()) {
          status = "Game over, stalemate";
        }

        // check for threefold repetition
        else if (game.in_threefold_repetition()) {
          status = "Game over, threefold repetition";
        }

        // check for insufficient material
        else if (game.insufficient_material()) {
          status = "Game over, insufficient material";
        }

        // check for 50-move rule
        else if (game.half_moves >= 100) {
          status = "Game over, 50-move rule";
        }

        if (status !== "") {
          displayLogMessage(status);
        }
      }

      function sendMoveToServer(move) {
        // Show the waiting message
        document.getElementById("waiting-message").style.display = "block";

        $.ajax({
          url: "/move",
          method: "POST",
          data: {
            from: move.from,
            to: move.to,
            promotion: move.promotion,
          },
          success: function (response) {
            // Hide the waiting message
            document.getElementById("waiting-message").style.display = "none";

            // Check if response.bestMove exists
            if (response.move) {
              var move = response.move;
            } else {
              // Fallback to parsing the string if response.bestMove is not available
              var move = response.split("move:")[1]?.trim().split(" ")[0];
            }
            if (move) {
              game.move(move, { sloppy: true });
              board1.position(game.fen());
              updateStatus();
            }
          },
        });
      }

      // Function to delete the session
      async function deleteSession() {
        try {
          const response = await fetch("/delete-session");
          const data = await response.json();
          if (data.status === "success") {
          } else {
          }
        } catch (error) {
        }
      }

      async function getLogs() {
        try {
          const response = await fetch("/get_logs");
          const data = await response.json();
          if (data.log) {
            // Create a new div for the log entry
            const logEntry = document.createElement("div");

            // Check if the log is an error or success, and set the color accordingly
            if (data.log.includes("illegal")) {
              logEntry.style.color = "red";
            } else {
              logEntry.style.color = "green";
            }
            // Set the log entry text
            logEntry.innerHTML = data.log;
            // Append the log entry to the log container
            document.getElementById("log").appendChild(logEntry);
          }
        } catch (error) {
          console.error("Error fetching logs:", error);
        } finally {
          // Call getLogs again after 3 seconds
          setTimeout(getLogs, 500);
        }
      }
      // Add this function in your script tag
      function startRealTimeLogs() {
        getLogs();
        setTimeout(startRealTimeLogs, 1000);
      }

      // Call deleteSession when the page is reloaded
      window.addEventListener("load", deleteSession);
    </script>
  </body>
</html>
